open! Prelude

type t = {
  trait_goal : Ast.Rust.trait_goal option;
      (** The trait implemented by the [impl] block or [None] if the
         [impl] block is an {{: https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations } inherent [impl]}.
        *)
  typ : Ast.Rust.ty;  (** The type implemented by the [impl] block. *)
  predicates : Ast.Rust.trait_goal list;
      (** The predicates that constraint this [impl] block. *)
}
(** metadata of an [impl] block *)

(** Lookup the implementation informations given a concrete
ident. Returns [Some _] if and only if the supplied identifier points
to an [Impl].

{b WARNING}: due to {{: https://github.com/hacspec/hax/issues/363}
issue 363}, when looking up certain identifiers generated by the
engine, this function may return [None] even though the supplied
identifier points to an [Impl] block. *)
let lookup span (impl : Concrete_ident.t) : t option =
  let* Types.{ generics = _; predicates; typ; trait_ref } =
    Concrete_ident.lookup_raw_impl_info impl
  in
  let trait_goal =
    Option.map ~f:(Import_thir.import_trait_ref span) trait_ref
  in
  let typ = Import_thir.import_ty span typ in
  let predicates =
    let f (binder : Types.binder_for__predicate_kind) =
      Import_thir.import_predicate_kind span binder.value
    in
    List.filter_map ~f predicates
  in
  Some { trait_goal; typ; predicates }
