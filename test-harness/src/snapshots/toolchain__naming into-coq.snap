---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: coq
  info:
    name: naming
    manifest: naming/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: false
      stdout: true
---
exit = 0

[stdout]
diagnostics = []

[stdout.files]
"Naming.F.G.Impl_1.G.Hello.v" = '''
(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

Definition h : unit :=
  tt.
'''
"Naming.v" = '''
(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

Record Foo_B : Type :={
  f_x : uint_size;
}.
Inductive t_Foo : Type :=
| Foo_At_Foo
| Foo_B : Foo_B -> t_Foo.

Record t_C : Type :={
  f_x : uint_size;
}.

Record t_X : Type :={
}.

Record t_B : Type :={
}.

Record t_Foobar : Type :={
  f_a : t_Foo_t;
}.

Definition ff__g__impl_1__g (self : t_Foo_t) : uint_size :=
  (@repr WORDSIZE32 1).

Class t_T3_e_for_a Self := {
}.

Record t_Arity1 : Type :={
  0 : T;
}.

Class t_T2_for_a Self := {
}.

Class t_T1 Self := {
}.

Definition reserved_names (val : int8) (noeq : int8) (of : int8) : int8 :=
  (val.+noeq).+of.

Definition mk_c : t_C_t :=
  let _ := (Build_Foo_B (@repr WORDSIZE32 3)) : t_Foo_t in
  let _ := (Xt_X_t) : t_X_t in
  Build_C (@repr WORDSIZE32 3).

(*Not implemented yet? todo(item)*)

Record C_f__g__impl__g__Foo_B : Type :={
  f_x : uint_size;
}.
Inductive t_f__g__impl__g__Foo : Type :=
| C_f__g__impl__g__Foo_At_f__g__impl__g__Foo
| C_f__g__impl__g__Foo_B : C_f__g__impl__g__Foo_B -> t_f__g__impl__g__Foo.

Definition ff__g__impl__g (self : t_B_t) : uint_size :=
  (@repr WORDSIZE32 0).

Definition ff__g : unit :=
  tt.

Definition f (x : t_Foobar_t) : uint_size :=
  ff__g__impl_1__g (f_a x).

(*Not implemented yet? todo(item)*)

Record Foo2_B : Type :={
  f_x : uint_size;
}.
Inductive t_Foo2 : Type :=
| Foo2_At_Foo2
| Foo2_B : Foo2_B -> t_Foo2.

Instance t_Foo_t_t_T3_e_for_a : t_T3_e_for_a t_Foo_t := {
}.

Instance t_Arity1_t (t_Foo_t × int8)_t_T2_for_a : t_T2_for_a t_Arity1_t (t_Foo_t × int8) := {
}.

Instance (t_Foo_t × int8)_t_T1 : t_T1 (t_Foo_t × int8) := {
}.

Instance t_Foo_t_t_T1 : t_T1 t_Foo_t := {
}.

Definition impl__B__f (self : t_B_t) : t_B_t :=
  Bt_B_t.

Definition impl__Foo__f (self : t_Foo_t) : t_Foo_t :=
  Foo_At_Foo_t.
'''
