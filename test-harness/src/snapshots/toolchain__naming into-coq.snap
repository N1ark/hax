---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: coq
  info:
    name: naming
    manifest: naming/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: false
      stdout: true
---
exit = 101
[[stdout.diagnostics]]
message = '''
(Coq backend) something is not implemented yet.
[ty] node str'''
spans = ['Span { lo: Loc { line: 110, col: 4 }, hi: Loc { line: 112, col: 5 }, filename: Real(LocalPath("naming/src/lib.rs")) }']

[stdout.files]
"Naming.Ambiguous_names.v" = '''
(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

(*Not implemented yet? todo(item)*)

(*item error backend*)

Definition f : unit :=
  let a_1 := ((@repr WORDSIZE32 104)) : int32 in
  let a_2 := ((@repr WORDSIZE32 205)) : int32 in
  let a_3 := ((@repr WORDSIZE32 306)) : int32 in
  let a := ((@repr WORDSIZE32 123)) : int32 in
  let _ := (debug 3 a_3) : unit in
  let _ := (debug 2 a_2) : unit in
  let _ := (debug 1 a_1) : unit in
  debug last a.
'''
"Naming.F.G.Impl_1.G.Hello.v" = '''
(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

Definition h : unit :=
  tt.
'''
"Naming.v" = '''
(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

Record Foo_B : Type :={
  f_x : uint_size;
}.
Inductive t_Foo : Type :=
| Foo_At_Foo
| Foo_B : Foo_B -> t_Foo.

Definition impl__Foo__f (self : t_Foo_t) : t_Foo_t :=
  Foo_At_Foo_t.

Record Foo2_B : Type :={
  f_x : uint_size;
}.
Inductive t_Foo2 : Type :=
| Foo2_At_Foo2
| Foo2_B : Foo2_B -> t_Foo2.

Class t_FooTrait Self := {
  f_ASSOCIATED_CONSTANT:uint_size ;
}.

Class t_T1 Self := {
}.

Instance t_Foo_t_t_T1 : t_T1 t_Foo_t := {
}.

Instance (t_Foo_t × int8)_t_T1 : t_T1 (t_Foo_t × int8) := {
}.

Class t_T2_for_a Self := {
}.

Class t_T3_e_for_a Self := {
}.

Instance t_Foo_t_t_T3_e_for_a : t_T3_e_for_a t_Foo_t := {
}.

(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

Definition v_INHERENT_CONSTANT : uint_size :=
  (@repr WORDSIZE32 3).

Definition constants : uint_size :=
  f_ASSOCIATED_CONSTANT.+v_INHERENT_CONSTANT.

Definition ff__g : unit :=
  tt.

Record C_f__g__impl__g__Foo_B : Type :={
  f_x : uint_size;
}.
Inductive t_f__g__impl__g__Foo : Type :=
| C_f__g__impl__g__Foo_At_f__g__impl__g__Foo
| C_f__g__impl__g__Foo_B : C_f__g__impl__g__Foo_B -> t_f__g__impl__g__Foo.

Definition ff__g__impl_1__g (self : t_Foo_t) : uint_size :=
  (@repr WORDSIZE32 1).

(*Not implemented yet? todo(item)*)

Definition reserved_names (val : int8) (noeq : int8) (of : int8) : int8 :=
  (val.+noeq).+of.

Record t_Arity1 : Type :={
  0 : T;
}.

Instance t_Arity1_t (t_Foo_t × int8)_t_T2_for_a : t_T2_for_a t_Arity1_t (t_Foo_t × int8) := {
}.

Record t_B : Type :={
}.

Definition impl__B__f (self : t_B_t) : t_B_t :=
  Bt_B_t.

Record t_C : Type :={
  f_x : uint_size;
}.

Record t_Foobar : Type :={
  f_a : t_Foo_t;
}.

Record t_StructA : Type :={
  f_a : uint_size;
}.

Record t_StructB : Type :={
  f_b : uint_size;
  f_a : uint_size;
}.

Record t_StructC : Type :={
  f_a : uint_size;
}.

Record t_StructD : Type :={
  f_b : uint_size;
  f_a : uint_size;
}.

Record t_X : Type :={
}.

Definition construct_structs (a : uint_size) (b : uint_size) : unit :=
  let _ := (Build_StructA a) : t_StructA_t in
  let _ := (Build_StructB ab) : t_StructB_t in
  let _ := (Build_StructC a) : t_StructC_t in
  let _ := (Build_StructD ab) : t_StructD_t in
  tt.

Definition f (x : t_Foobar_t) : uint_size :=
  ff__g__impl_1__g (f_a x).

Definition ff__g__impl__g (self : t_B_t) : uint_size :=
  (@repr WORDSIZE32 0).

Class t_T1 Self := {
}.

Instance t_Foo_t_t_T1 : t_T1 t_Foo_t := {
}.

Instance (t_Foo_t × int8)_t_T1 : t_T1 (t_Foo_t × int8) := {
}.

Class t_T2_for_a Self := {
}.

Class t_T3_e_for_a Self := {
}.

Instance t_Foo_t_t_T3_e_for_a : t_T3_e_for_a t_Foo_t := {
}.

(*Not implemented yet? todo(item)*)

Definition ff__g : unit :=
  tt.

Record C_f__g__impl__g__Foo_B : Type :={
  f_x : uint_size;
}.
Inductive t_f__g__impl__g__Foo : Type :=
| C_f__g__impl__g__Foo_At_f__g__impl__g__Foo
| C_f__g__impl__g__Foo_B : C_f__g__impl__g__Foo_B -> t_f__g__impl__g__Foo.

Definition ff__g__impl_1__g (self : t_Foo_t) : uint_size :=
  (@repr WORDSIZE32 1).

(*Not implemented yet? todo(item)*)

Definition reserved_names (val : int8) (noeq : int8) (of : int8) : int8 :=
  (val.+noeq).+of.

Record t_Arity1 : Type :={
  0 : T;
}.

Instance t_Arity1_t (t_Foo_t × int8)_t_T2_for_a : t_T2_for_a t_Arity1_t (t_Foo_t × int8) := {
}.

Record t_B : Type :={
}.

Definition impl__B__f (self : t_B_t) : t_B_t :=
  Bt_B_t.

Record t_C : Type :={
  f_x : uint_size;
}.

Record t_Foobar : Type :={
  f_a : t_Foo_t;
}.

Record t_X : Type :={
}.

Definition f (x : t_Foobar_t) : uint_size :=
  ff__g__impl_1__g (f_a x).

Definition ff__g__impl__g (self : t_B_t) : uint_size :=
  (@repr WORDSIZE32 0).

Definition mk_c : t_C_t :=
  let _ := (Build_Foo_B (@repr WORDSIZE32 3)) : t_Foo_t in
  let _ := (Xt_X_t) : t_X_t in
  Build_C (@repr WORDSIZE32 3).
'''
