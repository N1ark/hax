---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: ssprove
  info:
    name: conditional-match
    manifest: conditional-match/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 101
stderr = '''
Compiling conditional-match v0.1.0 (WORKSPACE_ROOT/conditional-match)
error[HAX0008]: (reject_MatchGuard) ExplicitRejection { reason: "a node of kind [Match_guard] have been found in the AST" }
  --> conditional-match/src/lib.rs:31:9
   |
31 |         Foo { a, .. } if a > 10 => 1,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[HAX0001]: (SSProve backend) something is not implemented yet.
                [pat] node record pattern
  --> conditional-match/src/lib.rs:24:9
   |
24 |         Foo { c, .. } => 1,
   |         ^^^^^^^^^^^^^

error: could not compile `conditional-match` (lib) due to 2 previous errors'''
[[stdout.diagnostics]]
message = '(reject_MatchGuard) ExplicitRejection { reason: "a node of kind [Match_guard] have been found in the AST" }'
spans = ['Span { lo: Loc { line: 31, col: 8 }, hi: Loc { line: 31, col: 36 }, filename: Real(LocalPath("conditional-match/src/lib.rs")) }']

[[stdout.diagnostics]]
message = '''
(SSProve backend) something is not implemented yet.
[pat] node record pattern'''
spans = ['Span { lo: Loc { line: 24, col: 8 }, hi: Loc { line: 24, col: 21 }, filename: Real(LocalPath("conditional-match/src/lib.rs")) }']

[stdout.files]
"Conditional_match.v" = '''
(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Definition t_Foo : choice_type :=
  (int8 × 'bool × int16).
Equations f_a {L : {fset Location}} {I : Interface} (s : both L I t_Foo) : both L I int8 :=
  f_a s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst x) : int8))) : both L I int8.
Fail Next Obligation.
Equations f_b {L : {fset Location}} {I : Interface} (s : both L I t_Foo) : both L I 'bool :=
  f_b s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : 'bool))) : both L I 'bool.
Fail Next Obligation.
Equations f_c {L : {fset Location}} {I : Interface} (s : both L I t_Foo) : both L I int16 :=
  f_c s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : int16))) : both L I int16.
Fail Next Obligation.
Equations Build_t_Foo {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {f_a : both L0 I0 int8} {f_b : both L1 I1 'bool} {f_c : both L2 I2 int16} : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_Foo) :=
  Build_t_Foo  :=
    bind_both f_c (fun f_c =>
      bind_both f_b (fun f_b =>
        bind_both f_a (fun f_a =>
          solve_lift (ret_both ((f_a,f_b,f_c) : (t_Foo)))))) : both (L0:|:L1:|:L2) (I0:|:I1:|:I2) (t_Foo).
Fail Next Obligation.
Notation "'Build_t_Foo' '[' x ']' '(' 'f_a' ':=' y ')'" := (Build_t_Foo (f_a := y) (f_b := f_b x) (f_c := f_c x)).
Notation "'Build_t_Foo' '[' x ']' '(' 'f_b' ':=' y ')'" := (Build_t_Foo (f_a := f_a x) (f_b := y) (f_c := f_c x)).
Notation "'Build_t_Foo' '[' x ']' '(' 'f_c' ':=' y ')'" := (Build_t_Foo (f_a := f_a x) (f_b := f_b x) (f_c := y)).

(*item error backend*)

Equations v_Baz {L1 : {fset Location}} {I1 : Interface} (foo : both L1 I1 t_Foo) : both L1 I1 'unit :=
  v_Baz foo  :=
    letb _ := failure (ret_both ((reject_MatchGuard) ExplicitRejection { reason: "a node of kind [Match_guard] have been found in the AST" }
 : chString)) (ret_both ((match foo {
        conditional_match::Foo { f_a: a } if core::cmp::PartialOrd::gt(a, 10) => 1,
        conditional_match::Foo { f_b: b } if b => 2,
        _ => 3,
    }) : chString)) in
    solve_lift (ret_both (tt : 'unit)) : both L1 I1 'unit.
Fail Next Obligation.

Equations v_Foo {L1 : {fset Location}} {I1 : Interface} (_ : both L1 I1 'unit) : both L1 I1 'unit :=
  v_Foo _  :=
    letb foo := Build_t_Foo (f_a := ret_both (16 : int8)) (f_b := ret_both (false : 'bool)) (f_c := ret_both (9 : int16)) in
    letb bar := Build_Foo[foo] (f_c := ret_both (14 : int16)) in
    solve_lift (ret_both (tt : 'unit)) : both L1 I1 'unit.
Fail Next Obligation.
'''
